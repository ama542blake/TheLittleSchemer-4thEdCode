#lang scheme

; 1st Commandment update: When recurring on a number always ask (zero? n) and else
; 4th Commandment update: When using sub1, test termination with zero?

(define add1
  (lambda (n)
    (+ n 1)))

(define sub1
  (lambda (n)
    (- n 1)))

(define add
  (lambda (n m)
    (cond
      ((zero? m) n)
      (else (add (add1 n) (sub1 m))))))

(define sub
  (lambda (n m)
    (cond
      ((zero? m) n)
      (else (sub (sub1 n) (sub1 m))))))

(define addtup
  (lambda (tup)
    (cond
      ((null? tup) 0)
      (else (add (car tup) (addtup (cdr tup)))))))

(define mult
  (lambda (n m)
    (cond
      ((zero? m) 0)
      (else (add n (mult n (sub1 m)))))))

; 5th Commandment: When building a value with plus, always use 0 for the value of the terminating line, for adding 0 does not change the value of an addition.
;                  When building a value with mult, always use 1 for the value of the terminating line, for multiplying by 1 does not change the value of a multiplication.
;                  When building a value with cons, always consider () for the value of the terminating line.

; adds two lists (which must be the same size n) element by element and returns a new list of length n with the results of each addition
(define tup+
  (lambda (tup1 tup2)
    (cond
      ((and (null? tup1) (null? tup2)) '())
      (else (cons
             (add (car tup1) (car tup2))
             (tup+ (cdr tup1) (cdr tup2)))))))

; like tup+, but allows tuples to be of different lengths
(define tup+dl
  (lambda (tup1 tup2)
    (cond
      (and (null? tup1) (null? tup2)) '()
      (else (cond
              ((null? tup1) tup2)
              (else (null? tup2) tup1))) ; not done: p71



